// COPYRIGHT 2009, 2010, 2011, 2012, 2013 by the Open Rails project.
// 
// This file is part of Open Rails.
// 
// Open Rails is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Open Rails is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Open Rails.  If not, see <http://www.gnu.org/licenses/>.

/* LOCOMOTIVE CLASSES
 * 
 * Used as a base for Steam, Diesel and Electric locomotive classes.
 * 
 * A locomotive is represented by two classes:
 *  MSTSLocomotive - defines the behaviour, ie physics, motion, power generated etc
 *  MSTSLocomotiveViewer - defines the appearance in a 3D viewer including animation for wipers etc
 *  
 * Both these classes derive from corresponding classes for a basic TrainCar
 *  TrainCar - provides for movement, rolling friction, etc
 *  TrainCarViewer - provides basic animation for running gear, wipers, etc
 *  
 * Locomotives can either be controlled by a player, 
 * or controlled by the train's MU signals for brake and throttle etc.
 * The player controlled loco generates the MU signals which pass along to every
 * unit in the train.
 * For AI trains, the AI software directly generates the MU signals - there is no
 * player controlled train.
 * 
 * The end result of the physics calculations for the the locomotive is
 * a TractiveForce and a FrictionForce ( generated by the TrainCar class )
 * 
 */

using System.IO;

using Microsoft.Xna.Framework;

using Orts.Formats.Msts.Parsers;

namespace Orts.Simulation.RollingStocks
{
    /// <summary>
    /// Extended CVF data, currently used for CAB light
    /// By GeorgeS
    /// </summary>
    //[OrtsPhysicsFile("lit", "ORTSExtendedCVF")]
    public class ExtendedCVF
    {
        // migrated and refactored from OrtsPhysicsFileAttribute and OrtsPhysicsAttribute
        private const string token = "ORTSExtendedCVF";
        private const string extension = "lit";

        /// <summary>
        /// Translate to current screen resolution
        /// </summary>
        /// <param name="displaySize">Current screen resolution</param>
        /// <returns>Translated vectors</returns>
        public static Vector4 TranslatedPosition(Vector4 Position, Point displaySize)
        {
            return new Vector4(Position.X / 640 * displaySize.X,
                Position.Y / 480 * displaySize.Y,
                Position.Z / 640 * displaySize.X,
                Position.W);
        }

        internal virtual void Initialize(string wagFilePath)
        {
            string fileName = Path.ChangeExtension(wagFilePath, extension);
            if (File.Exists(fileName))
            {
                using (STFReader stf = new STFReader(fileName, false))
                {

                    stf.MustMatch(token);
                    stf.MustMatch("(");
                    stf.ParseBlock(new STFReader.TokenProcessor[] {
                            new STFReader.TokenProcessor("light1position", () =>
                            {
                                Vector4 l1 = Light1Position;
                                stf.ReadVector4Block(STFReader.Units.Any, ref l1);
                                Light1Position = l1;
                            }),
                            new STFReader.TokenProcessor("light1colorargb", () =>
                            {
                                Vector4 v4 = new Vector4(-1);
                                stf.ReadVector4Block(STFReader.Units.Any, ref v4);
                                Color c = new Color();
                                if (v4.W == -1)
                                {
                                    c.A = 255;
                                    c.R = v4.X == -1 ? c.R : (byte)v4.X;
                                    c.G = v4.Y == -1 ? c.G : (byte)v4.Y;
                                    c.B = v4.Z == -1 ? c.B : (byte)v4.Z;
                                }
                                else
                                {
                                    c.A = v4.X == -1 ? c.A : (byte)v4.X;
                                    c.R = v4.Y == -1 ? c.R : (byte)v4.Y;
                                    c.G = v4.Z == -1 ? c.G : (byte)v4.Z;
                                    c.B = v4.W == -1 ? c.B : (byte)v4.W;
                                }
                                Light1Color = c;
                            }),
                            new STFReader.TokenProcessor("light2position", () =>
                            {
                                Vector4 l2 = Light1Position;
                                stf.ReadVector4Block(STFReader.Units.Any, ref l2);
                                Light2Position = l2;
                            }),
                            new STFReader.TokenProcessor("light2colorargb", () =>
                            {
                                Vector4 v4 = new Vector4(-1);
                                stf.ReadVector4Block(STFReader.Units.Any, ref v4);
                                Color c = new Color();
                                if (v4.W == -1)
                                {
                                    c.A = 255;
                                    c.R = v4.X == -1 ? c.R : (byte)v4.X;
                                    c.G = v4.Y == -1 ? c.G : (byte)v4.Y;
                                    c.B = v4.Z == -1 ? c.B : (byte)v4.Z;
                                }
                                else
                                {
                                    c.A = v4.X == -1 ? c.A : (byte)v4.X;
                                    c.R = v4.Y == -1 ? c.R : (byte)v4.Y;
                                    c.G = v4.Z == -1 ? c.G : (byte)v4.Z;
                                    c.B = v4.W == -1 ? c.B : (byte)v4.W;
                                }
                                Light2Color = c;
                            }),
                        });
                }
            }
        }

        /// <summary>
        /// Used by the shader
        /// </summary>
        public static Vector3 TranslatedColor(Color Color)
        {
            return new Vector3((float)Color.R / 255, (float)Color.G / 255, (float)Color.B / 255);
        }

        //[OrtsPhysics("First light Position", "Light1Position", "The position and aspect of the first cab light", "320 360 155 2")]
        /// <summary>
        /// The position and aspect of the first cab light
        /// </summary>
        public Vector4 Light1Position { get; private set; } = new Vector4(320, 360, 155, 2);

        //[OrtsPhysics("First light ARGB", "Light1ColorARGB", "The color of the first cab light", "255 216 178 255")]
        /// <summary>
        /// The color of the first cab light
        /// </summary>
        public Color Light1Color { get; private set; } = new Color(255, 216, 178, 255);

        //[OrtsPhysics("Second light Position", "Light2Position", "The position and aspect of the first cab light", "0 0 0 0")]
        /// <summary>
        /// The position and aspect of the first cab light
        /// </summary>
        public Vector4 Light2Position { get; private set; }

        //[OrtsPhysics("Second light ARGB", "Light2ColorARGB", "The color of the second cab light", "0 0 0")]
        /// <summary>
        /// The color of the second cab light
        /// </summary>
        public Color Light2Color { get; private set; }


    } // End Class ExtendedCVF 
}
